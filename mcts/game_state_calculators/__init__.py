"""
Game State Calculator
=====================

Game state calculators provide mcts with the knowledge of the game. When
MCTS is run, instead of using game states to guide the search, MCTS will
generate a game state calculator using the given game state. The search
tree generated by MCTS may be large, so this functionality allows one to
optimize depending on the game. For example, the three-fold repetition rule
in chess makes game states take up much more space than the board position.
A game state calculator may use the way mcts generates the tree to reduce
the space constraints.

Default game state calculators are provided in this package.
 
MCTS will use the default game state calculator if the game do not provide 
with one with the function with signature game_state_calculator(game_state).

A game state calculator protocol consists of the following:

--> def request_root() -> Game state information
                           
Provides the game information of the state corresponding to the root.
The root is the game state used to initalize the game state calculator.

--> def move_iterator() -> Game Iterator

Returns a game iterator which is initialized at the root.



Game State Information
----------------------

This is a data class which holds the following information about a game
state as attributes:

is_game_over
game_final_evaluation
game_state
legal_moves
turn


Game iterator
-------------

MCTS will use the iterators it obtained from the move_iterator method to
traverse the game tree. MCTS will not go deeper than 1 ply after a game
state it has asked about before. MCTS will call terminate() to obtain
the game information, and to inform the game state calculator that it has
finished this iterator.

Game iterator protocol consists of:

--> def next_outcome(game_move) -> game outcome

Iterator uses the move to go one ply deeper into the game tree. The iterator 
will pick the probabilistic outcome of the move according to the rules of 
the game, and return it. 

--> def terminate() -> Game state information

Iterator returns the game state information at the last state it was in.
After this methodis called, the iterator is finished, and is not used further.
MCTS is guaranteed to terminate the iterator at a game over state or at the
first non-visited game state encountered.

"""

